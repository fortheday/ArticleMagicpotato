# 개발철학에 관한 이야기 Edited
원제목: 당신의 true는 어째서 그들에게 true가 아닌가

> 이 글을 처음 쓴 것은 10년 정도 경력을 쌓은 시기, 대략 2010년 근처일 것이다. 홈페이지를 날려먹은지 수 년이 지난 다음 예전 글들을 찾아내서 git로 복구하다가 발견했다. 지금(2018)도 근본적인 개발마인드는 비슷하지만, 나이들고 읽어보니 사회성이 부족할 때 쓴 글이라 다른사람들의 입장을 너무 쉽게 이야기하는게 보기 불편해서 완만하게 다듬어 보려 한다.

> 당시 실무에 대해 많은 고민을 하고, 그것을 토대로 단단한 개발철학을 세웠다. 고민의 과정에서 도출된 결론들을 내 것으로 만들고 8년간 숨 쉬듯 사용해 왔다. 지금도 상당히 잘 써먹고 있지만 깊은 내면 어딘가에 금이 가는 느낌이 들었는데 이 글을 다시 찾아낸 것은 내게 큰 행운이다. (KSW님 감사합니다.)


## 목차
0. 들어가기
1. 준비1 : 우리는 타인으로부터, 사람으로부터 배운다.
2. 준비2 : 우리는 어떤 사람으로부터 어떤 것을 배우는가?
3. 개발철학
4. 나의 개발철학 위에 쌓은 세부 업무 규칙 (예시)
5. 시야 : 기술밖에 몰랐던 바보가 경력자가 되어 들려주고 싶은 이야기


## 0. 들어가기

이 글은 **팀 정책**을 고려하지 않고 자신만의 개발 방법만을 고집하여 업무적 충돌이 자주 발생하거나 시키는대로는 일하지만 마음속 깊은 곳에서 스트레스가 쌓여가는 프로그래머를 위한 글이다.

> 글을 다듬는 현재는 나를 위해 쓰는 글이기도 하다. 내가 해 왔던 많은 고민들을 가끔 다시 꺼내서 복습하려는 목적도 있다. 고치거나 추가하고 싶은 이야기가 많지만 다른 글들을 다 복구한 다음 한 번 더 업데이트를 하려 한다.

이런 프로그래머들은 주로 단방향 형태의 매체를 이용하여 숙련되었을 가능이 높다고 생각한다. 나도 그랬고, 대부분의 프로그래머들은 자신의 지식이 참이라는것에 강한 자신을 갖고 있고, 스스로가 일을 잘 한다고 확신한다. 이 글을 통해 정말 잘 하고있는지 재 확인하고 만약 그렇다면 으쓱대자. 그게 아니라면 생각을 업그레이드하고 더 **조직에 적합한** 프로그래머가 되는 계기가 되면 좋겠다.

이 글에서 2가지를 말하고자 한다. 프로그래머들 간의 기술적 충돌은 근본적으로 (1)개발철학과 (2)시야에 있다고 생각한다.


## 1. 준비1 : 우리는 타인으로부터, 사람으로부터 배운다.

배움의 출처는 근본적으로 사람이다. 책도 레퍼런스도 사람이 쓴다. 그런데 사람은 오류를 일으킬 수 있는 존재이다. 실수로 내게 틀리게 알려주고 체면때문에 고쳐주지 않을 수도 있다. 이상하게 우리는 서점에 가격이 매겨진 책들은 무조건 옳을 것이라는 믿음을 갖고 있다. 보수를 받고 책을 쓴 사람도 어떨 때는 귀찮거나 졸려서 대충 쓰거나 사실관계를 확인하지 않은 부분이 있을 수 있다. 텍스트를 맹신해서는 안된다. 그리고 이 글도 사람이 쓰고 있다.

사람은 저마다 국가, 문화, 소속된 집단이 다르다. 개발환경도 모두 다르다. 우리는 근본적으로 이런 다양한 사람들에게 무언가를 배운다. 


## 2. 준비2 : 우리는 어떤 사람으로부터 어떤 것을 배우는가?

프로그래머가 읽는 C++등의 입문서는 독자에게 스며들어서 결과적으로 큰 영향을 미친다. 코딩습관, 개발철학, 인생에 까지 영향을 미치기도 한다. **코딩습관**과 **개발철학**이라는 2개의 단어는 0.1 초만에 가볍게 지나쳐도 되는 단어가 아니다. 엄청난 것들을 담은 단어다. 아래의 다양한 환경에서 쓰여진 책들이 읽는 사람에게 어떤 영향(**코딩습관, 개발철학**)을 미칠 지 생각 해보자.

1. 수 천명이 참여하는 NASA 우주선 발사 프로젝트 소속의 프로그래머가 쓴 'C++ 프로그래밍'
2. 유명 모바일게임 프로젝트 팀장이 쓴 'C++ 프로그래밍'
3. 개복치 모바일게임 개발자가 쓴 'C++ 프로그래밍'

생각하기 편하도록 과장하였다. 같은 제목이지만 3가지 책은 서로 다를 것이다. A라는 사람은 (1)로 C++을 배우고, B라는 사람은 (3)으로 C++을 배웠다고 할 때 이 두 사람은 엄청 큰 차이를 갖게 된다. 나는 중학생 때 프로그래밍 책의 '저자약력'을 통해 이것을 유추하는 것을 누구에게도 배우지 못했다.

내가 배운 프로그래밍은 **어떤** 사람으로부터 전수받은 것일까? 이 프로그래밍은 내가 속한 조직이 원하는 프로그래밍일까?


## 3. 개발철학

앞 선 이야기를 통해, 내가 전수받은 코딩, 설계, 업무 기술이 내 개발환경에 딱 맞지 않을 수 있다는 이야기를 했다. 자신이 옳다고 생각하는 방식으로 일을 하려면 어떠한 기준-**개발철학**을 가져야 한다. 자기 것이 없다면 소속팀의 개발철학이라도 파악해야 한다. 개발철학을 재 점검하고, **개발팀의 목표**와 **여러분의 목표**를 적절히 타협한 맞춤형 개발철학으로 업그레이드 하길 바란다.

이 글은 철학 세우는 법에 대한 글은 아니다. 이론적인 이야기를 할 능력도 없고, 그 것 보다는 나의 (1)개발철학이 무엇이며, 그것을 토대로 (2)상세 규칙들을 무엇으로 정했는지 실제 예시를 들 것이다.

강조하고 싶은 것은, **이 방법이 맞다고 말하는 것이 아니라는 것**이다. 이해를 돕기 위해 구체적으로 나의 '주장처럼 보이는' 개발철학을 공유하는 것이지, 이것이 옳다고 말 하는것이 아니다. 개발철학은 개개인이 처한 상황마다 달라야 한다.


### 개발철학 Layer 1

1. 급여를 받는 프로그래머는 회사가 돈을 벌 수 있는 방향에 초점을 두고 일 해야 한다.
2. 내가 담당한 업무 진행 도중에 설계나 코딩 기법을 결정하거나 선택할 때 회사에 도움이 되는 방향을 선택한다.
3. 회사 프로젝트를 이용해 나의 과도한 기술숙련을 하지 않는다.
4. 순수 프로그래머로서 누구에게 보여줘도 한 점 부끄럽지 않은 OOP의 원칙을 모두 지키는 완벽한 코드 구현은 추구하지 않는다. (그건 집에서, 연구팀에서)


### 개발철학 Layer 2

1. 최소비용으로 개발한다.
   1. 정말 필요한 일만 한다.
   2. 나로 인해 동료의 비용을 낭비시키지 않는다. (분석/감정/대화비용 등)
2. 내 업무의 딜레이로, 동료가 연관 업무를 하지 못하게 해서는 안된다.


### 개발철학 Layer 3

1. 코드를 쉽게 짠다. 분석비용을 낮추기 위해 과도한 트릭, 디자인패턴, 템플릿을 자제한다.
2. 코드를 플랫폼 종속적, 프로젝트 종속적으로 짠다. 확장성을 생각하지 않는다.
3. 어떤 코딩기법이나 기술 또는 툴을 사용하려면 '하고싶기 때문'이 아니라 '팀에 어떤 도움이 되기'때문이어야 한다. 그렇지 않다면 그만둬야 한다.

어떤 분들은 전혀 공감이 안 될수도 있다. 나는 저 철학을 세울 당시(그리고 이후로도) Research보다는 Development가 중요한 팀에서 오래 일했다. 자세한 배경은 아래에서 설명하겠다.

> 또 강조하고 싶지만, 나는 이런 개발자다로 받아들여 지길 원하지 않는다. 상황에 맞게 철학과 원칙을 재 구성할 줄 아는 개발자로 인식되길 원한다.


## 4. 나의 개발철학 위에 쌓은 세부 업무 규칙 (예시)

적재적소라는 말이 있듯이, 적절한 기술을 적절한 곳에 사용하는게 좋지 않을까? 그렇지 않은 것은 기술 오남용이 된다. 기술오남용의 가장 큰 이유는 자기 만족, 자기 자랑이라고 생각한다. 사실 별 의도는 없을것이지만, 자신의 가치를 만족하고 인정받기 위한 이유가 가장 크지 않을까?

기술만을 추구하는 테크니션을 넘어서서 know-where를 아는 개발자가 되어야 한다.

챕터3의 `나의 개발철학 Layer 3`에 이어서 `Layer 4 세부 업무 규칙`을 구체적으로 공유하면서 '왜'를 설명하고자 한다. 다시 강조하지만 **나의 개발환경**에 적합하다고 생각한 나만의 룰이지, 모든 개발자가 반드시 해야한다고 주장하는 것이 아니다.

나의 몇가지 룰들

1. 익스트림 프로그래밍의 페어프로그래밍은 효과적이지 않다.
2. 코드의 확장성은 고려하지 않는다.
3. OOP는 항상 옳지 않다.
4. goto도 하드코딩도 필요할 때가 있다.
5. namespace
6. 1 class 당 1 file
7. boost와 메타 프로그래밍
8. 템플릿
9. 디자인 패턴

오랜 기간동안 (과거에는 더 특히)프로그래밍 관련 기술에 관한 글이나 책을 읽을 때 단점을 이야기하는 것을 거의 보지 못했다. 대부분의 책은 왠지 저자들이 '확신'에 가득 차 있다.(그렇지 않으면 설득력이 없어 보이므로 그렇게 쓸 수밖에 없긴 하다)

모든 기술은 양면성을 갖고있다. 장단점이 있다는 뜻이다. 최고의 기술은 없다. 기술을 학습은 하되, 사용할 때 각자의 개발환경과 상황에 맞는 것인지 비판적 사고를 통해 걸러낼 수 있어야 한다.

이 챕터에서는 특히 '~이다'라고 단정 짓는 것을 '~라고 생각한다'로 받아들여주실 바란다. 글이 너무 길어진다.


### 1. 익스트림 프로그래밍의 페어프로그래밍은 효과적이지 않다.

한 모니터를 두 프로그래머가 쳐다보며 코딩하고 의견을 교환 하는건 프로젝트 초기에만 필요하다. 코드를 커밋하기 전에 관계가 업무 전혀 없는 사람과 코드리뷰를 하는 쪽이 훨씬 효율적이다.

정통 페어프로그래밍은 적어도 *내가 속한 개발환경*에는 절대 맞지 않는다. 페어프로그래밍은 그것을 할 수 있는 자세와 스킬을 갖춘 사람들이 필요할 때만 한정적으로 해야한다.


### 2. 코드의 확장성은 고려하지 않는다.

나는 경험이 없는 영역에 대해서 더이상 예측하지 않는다. 즉, 확장성을 고려하지 않는다. 또한 멀티플랫폼을 고려한 코딩을 하지 않는다. 내가 속한 프로젝트는 반드시 PC 온라인 게임만 만들기 때문.

경험하지 못한 영역을 공들여 고민하고 코딩한 다음, **확장성을 예측한 부분의 구조나 코드**를 거의 수정겂이 사용해 본 경험이 얼마나 되는가? 또 **확장될 것이라고 예측한 부분**이 프로젝트 완료시점에 모두 사용되었는가? 그렇지 않다면 불필요한데 시간을 쓴 것이다.

글을 리뉴얼중인 현재(2018년)는 예전보다도 더 프로젝트를 빨리 출시 하는것이 중요해 졌다. 그 전에 회사가 망하거나 경쟁작이 이미 완성되기 때문이다.

확장성을 고려하지 않아서 나중에 코드를 수정하다보면 "예측을 했더라면, 지금 이 업무를 안해도 될 텐데"라는 생각이 든다. 하지만 그 상황이 되었기 때문에 효율적으로 정확한 리팩토링을 할 수 있다는 것을 깨닳아야 한다.


### 3. OOP는 항상 옳지 않다.

스스로를 만족시키는 완벽한 OOP는 언제 완성될까? 게임기획서가 완전히 굳어지고, 정식 서비스를 통한 예외처리가 끝나서 더이상 고칠것이 없는 순간이다.

OOP가 필요한 분야가 있고, 아닌 분야가 있다. 엔진 설계를 하지 않는다면 `3단계 이상의 상속, 2클래스 이상의 다중상속`은 코드 분석비용을 급격히 증가시킨다. 2~3개의 코딩케이스가 나온 상태에서 중복 없앤다고 구조를 구체화 시키는 것은 대부분 이른 판단이다. 그 이후에도 반드시 수정이 생긴다.

나는 왜 OOP를 만족하는 코딩을 해야 한다고 생각하게 되었을까? 쉽고 직관적인 코드로 게임을 만들어서 회사가 굴러가고 내 이력서에 '완성된 게임'이 차곡차곡 쌓이는 것이 중요할까? 내가 만족하는 코드를 많이 작성 하는것이 중요할까?

어쨌든 OOP는 느리다. **고속**개발 컨셉과는 비껴져 있는 방법론이다.


### 4. goto도 하드코딩도 필요할 때가 있다.

Ada로 작성된 다음 코드를 보자.

```ada
-- 2중 루프 안에서 바깥 루프를 빠져나가는 코드

Outer_Loop :
	loop
		Inner_Loop :
			loop
				X := Rand;
				exit Outer_Loop when X > 5;
			end loop Inner_Loop;
	end loop Outer_Loop;
```

C++언어는 위와 같은 문법이 없다. 그래서 goto를 쓰는 것이다. goto 이외의 문법만으로 지저분해지는 상황이 있다. 그것을 goto로 해결할 수 있다.

더 나아가 매 순간 작성하는 코드의 성격에 따라 하드코딩이 필요한 경우가 있다.
다음 챕터에서도 하드코딩을 쓰면 좋은 경우를 설명하겠다.


### 5. namespace

나는 라이브러리 프로그래머가 아니다. 혹시 라이브러리 프로그래머라고 해도 내가 코딩하는 클래스 이름이 나중에 언젠가 연동할 라이브러리 이름과 겹칠까? 겹치게 되더라도 내 기능과 라이브러리의 기능을 동시에 사용할까? 또한 멀티플랫폼을 고려하지 않기때문에 플랫폼별로 제각각의 파일/소켓/오디오/렌더링 라이브러리를 사용하는 상황은 고려하지 않아도 된다.

나는 윈도우 플랫폼에서 게임브리오를 사용하고, winsock을 이용해 직접 짠 tcp, udp를 사용한다.
자료구조는 STL의 string, vector, map, list만 사용하며 다른것을 사용하지 않는다.
> 글 작성 당시의 이야기

std::string이라고 적지 않아도 우리팀 모든이가 STL임을 아는데 왜 std::를 항상 붙이는가?
언젠가 super_library::string같은 것을 혼용으로 쓸 생각이 있는가? 그럼 모든 std::string대신 super_library::string만 쓰면 되지 않을까?

.NET에서 ns로 라이브러리를 카테고리화 한게 멋있긴 하지만 .NET은 내가 최소 2년간 묶여있을 'IPv4 TCP,UDP, Win32 filesystem' 개발환경만을 고려하고 만든게 아니다.
> 실제로 2년이 아니라 4년6개월 이상 개발했다.

`언젠가, 만약`이라는 이유로 코딩을 하는것은 비효율적이다.

> namespace는 20명 이상의 프로그래머가 있는 대규모 개발환경이나, 프레임워크급 프로젝트에서 적합하다고 생각한다.


### 6. 1 class 당 1 file

나는 `분석비용`이라는 개념은 상당히 중요하게 생각한다. 초반에는 프로그래밍을 코딩하는것만 시간이 든다고 생각했지만, 나중에는 남의 코드를 읽고 이해하는 데 시간을 더 많이 사용하게 된다.

어떤 기능집합의 구조를 파악할 때, 하나의 헤더파일(또는 문서)만 보고 구조체-클래스간 협력구조(종속/상속/동등관계 등)를 파악할 수 있다면 분석비용이 낮은 것이다. 클래스 1개를 어떻게 짰는지보다 여러 자료구조들이 서로 어떻게 협력하는지 구조를 파악하는 것이 더 중요하다는 뜻이다.

보통 오픈소스 프로젝트나 실무에 투입되면 코드분석은 다음과 같이 이루어진다.

1. 설계구조 파악
2. 클래스별 공개 인터페이스 파악
3. 클래스별 내부구현 (멤버와 private함수) 파악

자바에서 하니까, 남들이 하니까, 파일이 너무 크니까, 오래전 부터 그렇게 해 왔으니까라는 이유로 모든 클래스를 각각의 파일로 나누는 것은 분석비용을 증가시킨다. 이것은 동료의 업무량을 늘리는 것이기도 하다.

> 요즘은 PC성능도 좋아지고 인텔리센스까지 더 강력해져서 굳이 파일을 잘게 쪼갤 필요가 없다.


### 7. boost와 메타 프로그래밍

개인적으로 부스트의 기능을 너무 좋아하지만, 조금이라도 실수하면 수정/디버깅 하는 비용이 크다. 유명한 라이브러리나 표준 라이브러리라고 해서 코드가 훌륭할 것이라고 생각해서는 안된다.(경력이 쌓이고 다시 봐도 여전히 같은 생각이다) MS의 개발자들이 작성한건데 내가 비판하면 실력이 없는거겠지? 라고 생각할 필요가 없다. 지저분하게 작성한 코드는 분명 지저분 한 것이다.

CRT, STL, boost 코드들은 이상하게 가독성이 많이 떨어진다. 2018년 현재는 조금 개선이 된 것 같지만.

서비스 중인 서버가 새벽2시에 터져서 자다 일어나서 쳐다볼 때 제 정신이 아니다. 만약 그 에러가 boost와 관련된 것일 때 boost코드를 들여다 본다고 생각해 보면 너무나도 끔찍하다.

boost의 컨셉은 단순하고 훌륭하지만, 코드는 아니다. C++의 가장 어려운 영역에 있는 코드 기법들을 사용한다. **분석비용**을 무시할 수 없다.


### 8. 템플릿

템플릿은 쓰지 말아야 한다.

사실 '정말 필요한 경우가 아니면 쓰지 말아야 한다'라고 말하고 싶지만, 이렇게 다짐하면 대부분은 정말 필요하지 않은데 사용하기 때문이다. 템플릿을 코딩할 때의 나는 너무 똑똑한 것 같다. 깔끔하고 기분도 좋다. 하지만 몇 개월이 지난 후 다시 쳐다보면 **분석비용**이 높은 편이다. 특히 템플릿템플릿, 단위전략, loki라이브러리는 학습적인 차원에서 한번 보고 말아야 하는 것들이다.

런타임의 계산을 컴파일타임에 한다는 컨셉 자체는 훌륭하지만, CPU파워를 우습게 보지 말자. 대부분은 가상함수면 충분하다. 클래스를 통째로 복사해서 붙여넣는게 기분은 별로지만, 실무에서는 더 효과적이다. 내가 걱정하는 성능은 대부분 문제가 되지 않는다.

> 가상함수의 성능이 걱정된다면 시대를 따라잡을 필요가 있다. 최적화 전략에 대해서 알아보자.

복붙된 두세개의 클래스를 모두 고칠 때마다 '템플릿으로 하면 깔끔할텐데..'라는 생각이 든다. 하지만 합치는 순간 더 고생하게 된다. 이런 정도의 찝찝함은 허용하고 갈 줄 알아야 한다.


### 9. 디자인 패턴

디자인 패턴책의 머릿글에서 왜 패턴이 좋은지 예시로 든 구문이다.

```
"님 이 코드는 뭐져?"
"xxx패턴을 찾아보세여"
```

커뮤니케이션을 단축시킨다는 차원에서 설명한 예시인데, 과장하면 다음과 같다.

```
"님 이 코드는 뭐져?"
"아인슈타인의 상대성 이론을 보시면 이해가 되는 코드입니다."
```

이미 이 코드가 뭐냐고 질문을 던진 순간부터, 그 코드는 복잡하고 어렵다는 뜻이다. 이런 경우 디자인패턴의 문제보다는 코드 작성자의 문제일 가능성이 높다. 디자인패턴을 적용하더라도 직관적으로 코딩하는 것이 중요하다.

디자인패턴은 개별 패턴들이 전반적으로 복잡한 구현법을 갖는다. 경력 프로그래머들이 빠지는 함정중의 하나는 '컨셉은 간단하니까'라는 것이다. 그런데 코드는 무지하게 어렵다.

C++/게임 프로젝트에서 디자인패턴의 시작인 싱글턴을 왜 써야 하는지 2018년이 된 지금도 크게 납득되지 않는다. Unity3D에서는 납득이 되며 실제로 나도 사용한다. 지금와서 생각해 보면 C++이 아닌 다른 언어에서는 디자인패턴이 유용할 수도 있다는 생각이 든다.

> C++할 때 쓴 글이므로, 소규모 C++ 게임 프로그래머에 입장에서 글을 마무리 할 것이다.

```
하나의 인스턴스가 보장되므로
```

내 개발환경에서 싱글턴은 하지 않아도 될 일을 만들어서 하게 한다.
싱글턴을 적용하는 건 보통 어떤 매니저들이다. File/Sound/Renderer 등. 게임프로젝트는 초기화 순서가 깔끔하게 떨어지지 않는다. 매니저급 클래스들은 생성 순서도 보장되어야 하고, 초기화 함수도 여러개로 나눠져서 정해진 순서대로 호출되어야 한다. 그래서 보통 CApplication::Initialize() 함수에 몰아져 있다. 즉, 싱글턴이 아무런 의미를 갖지 못한다는 뜻이다.

`전역 함수를 쓰지 말라`는 근거가 빈약한 원칙에 구속되서는 안된다. 이것은 `goto`와 비슷하다. CApplication에 매니저급 클래스들의 인스턴스나 포인터를 몰아놓으면 인스턴스 관리도 분명하고, 코드 분석비용도 내려간다.

비지터도 개념은 쉽다. Functor를 이용해서 Traverse를 사용하면 똑같은 기능을 쓸 수 있는데, 더 복잡한 코드를 짜는 이유가 뭘까?

### 정리

* 신 기술이니까, 배웠으니까 어딘가에 써먹어서는 안된다.
* 기술의 양면성을 항상 생각해야 한다.
* 테크닉을 많이 알지만, 적절한 위치에 적절한 것을 골라서 쓸 줄 알아야 한다.


## 5. 시야 : 기술밖에 몰랐던 바보가 경력자가 되어 들려주고 싶은 이야기

### 기술밖에 모르는 바보

순수한 프로그래머들은 자기들 입장에서 정직하게 원칙대로 일한다. 그리고 이상하게 상급자나 개발팀 이외의 사람들을 바보로 보거나 내 일을 방해하는 악당으로 본다. 과거 출판된 몇가지 책들이 소프트웨어 개발을 이해하지 못하는 관리자, 외부 팀에 대한 불신과 저항에 초점을 맞추고 있다. 이런것에 영향을 받은 개발자들이 많은 것 같다.

물론 그들이 소프트웨어 개발을 이해하지 못하는 것은 맞다. 하지만 프로그래머들 또한 그들을 이해하지 못하고 있다. 경력이 적거나, 기술에 집중하는 프로그래머들의 시야는 오직 구현에 집중되어있다. MyWorkEnvironment클래스에 대한 이해가 없다. 게임을 만드는데 연관된 모든 사람은 서로의 입장을 알아야 한다.

### 기술 외에 알아야 하는 것들

상황에 따라 다르지만, 우리는 모든 기능이 순차적으로 구현되어야 한다는 생각을 양보할 수 있어야 한다. 기획자/디자이너는 순서를 건너뛰고 돌아가는 것을 먼저 봐야 다음 일을 진행할 수 있는 경우가 있다. 머리속으로 상상하는 것과 눈으로 직접 보는것은 차이가 크다.

또한 개발자들은 재무적/경영전략적 사고방식을 어느정도 공부할 필요가 있다. 순수한 프로그래머들은 `돈이 되는 코드`에 대해서 고민해 본 경험이 적다. 이 의미를 이 글에서 설명하기에는 많은 준비가 필요하다. 한 번 쯤은 1인 게임개발을 통해서 직접 런칭하고, 광고도 해보고, 100원이라도 돈을 벌어보길 권장한다. 회사 일에 영향을 미치지 않는 선에서.

> 다시 강조하지만, 재무적 사고방식, 전략적 사고방식이라는 말의 의미와 연관되는 것들을 깊이 모른다면 미안하지만 그 프로그래머는 회사에 큰 도움이 안되고 있을 확률이 높다.

순수한 프로그래머들이 버그를 고치고 있는 와중에, PD나 팀장이 '내일 사업팀에서 구경 올거니까 겉보기에 좋은 것들을 구현해줘'라고 말하면 엄청난 짜증이 난다. 전통적인 소프트웨어 개발서적은 이런 상황에 "안됩니다 원칙이 아닙니다"라고 단호하게 말하라고 한다. 미안하지만 그건 너무 이상적인 답변이다. 이럴 때의 팁은, "지금 고치는 버그가 매우 중요하지만, 이 기능이 작동하지 않도록 막아놓겠습니다. 그리고 하드코딩으로 있어보이게는 하겠지만, 그 분들이 돌아간 뒤에 코드를 새로 짜야합니다. 일정을 더 주십시오"정도만 되도 훌륭한 답변이다.

> 이것 조차 받아들여지지 않는 회사도 있지만, 노코멘트 하겠다.

### 경력 프로그래머들이 오래된 방법을 고집하는 이유

서비스 경력이 오래된 프로그래머들은 구현 방법을 선택하는데 매우 보수적이다. 효율적인 방법이 아니더라도 한 번 검증된 방법이라면 그것을 택한다. 학원을 갓 나온 신입들은 기술개발을 게을리하는 고인물이라고 비난하지만, **서비스 한다**는 뜻의 무게감을 이해해 주었으면 한다. 이해가 안되면 제발 생각좀 했으면 한다.

게임을 완성하기 까지 해야할 '구현'이 엄청나게 많다. 많은 사람이 모여 작성한 기능들이 유기적으로 작동하는 것이 게임인데, 99%의 영역이 아무리 안정적이어도 코드 한줄만 삐끗해도 `잘못된 오류로 프로그램이 종료되었습니다`를 뱉어내는게 서비스의 현실이다.

여기서 중요한 것은, 그 비효율적인 이미 검증된 구현에서 문제가 생기는 것은 사소한 실수가 된다. `코드레벨의 실수`일 가능성이 매우 높기 때문이고, 무언가를 빠뜨렸어도 `무엇을 빠뜨렸는지` 알기가 쉽다. 하지만 새로운 방법론이나 설계구조, 코드기법에서 문제가 생긴다면 `무엇을 빠뜨렸는지` 알기가 상대적으로 어렵다. 그리고 설계상의 실수가 된다.

설계수준의 에러는 코드수준의 에러보다 훨씬 심각하고 위험부담이 크다. 설계가 잘못된 경우 버그를 수정해도 또다른 버그를 낳을 가능성이 매우 높다. 또 리팩토링의 부담도 생긴다.

> 오래된 방법만 쓰자고 주장 하는것이 아니다.

### 사람들은 당신의 잘못을 컴파일러처럼 간단하게 알려주지 않는다.

프로그래머들은 감정을 배제하고 대화하는 법을 수련한다. 아닌 것은 아니라고 솔직하게 이야기 하는것이 잘하는 것이라고 생각한다. 그리고 상대도 나에게 고칠 점 등을 솔직하게 이야기 해줘도 상처받지 않는다.

하지만 일반적인 사람들은 그렇지 않다. 일반적인 사람간의 소통에서 상대의 잘못을 이야기하는건 금기시 되어있다. 심지어 "화 안낼게 이야기 해봐"라고 말 해놓고도 화를 낸다. 이것을 바꾸려 하지 말아야 한다. 절대로 바뀌지 않는다. 즉, 당신에게 진실을 이야기 해 주지 않는다. 프로그래밍 기술만 들여다 보고 있지 말고, 스스로 알아내야 한다. 스스로 알아내야 할 그 기술을 `사회성, 소셜스킬`이라 한다.

### 마무리

굳이 나의 사생활을 다 이야기 하고 싶지는 않지만, 나 또한 같은 실수를 한 번씩은 하고, 답답했었고 시행착오를 겪었다. 나 또한 이름모를 많은 분들에게 배우고 그 분들에게 감사한 마음을 갖고 있다. 이 글이 어딘가에서 순수함을 갖고 너무 정직하게 일하는 프로그래머 한 명에게라도 도움이 되었으면 한다.


EOF