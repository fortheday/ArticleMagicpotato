# 언리얼 엔진 4 컨셉, 아키텍처

* magicpotato.

## 개요

이 문서는 언리얼 엔진 4의 전체 아키텍처를 정리하고, 언리얼 엔진 4의 핵심에 대해 설명한다. 언리얼 엔진 4의 공식 문서들은 부분적 이거나 기술 중심적으로 엔진을 설명하기때문에 몇 가지 정도의 문서만으로는 엔진의 컨셉과 구조를 이해하기 어렵다. 언리얼 엔진 4를 완전히 마스터 하기 위해서는 먼저 엔진 설계자(팀스위니)의 시각에서 언리얼이 추구하는 방향성과 아키텍쳐를 이해할 필요가 있다. 이것을 알고서 언리얼의 소스코드를 분석한다면 좀 더 도움이 될 것이다.


## 언리얼 엔진 4의 구현목표

일반적인 언리얼 엔진 학습자들은 엔진을 구성하는 많을 기술을 하나씩 익히면서 큰 그림을 그릴 수밖에 없다. 이것은 Bottom-Up 접근법인데, 여기에서는 반대방식인 Top-Down을 이용한다. 즉, `언리얼 엔진 4가 어떤것을 달성하기 위해서 이러한 기술들이 사용되었다`식으로 접근 하기 위해 아래 사항들을 염두해 두어야 한다.

```
  1. 강력하고 확장성 있는 엔진 (런타임)
  2. 강력하고 확장성 있는 에디터, 코딩 없는 비주얼 스크립팅으로 게임 만들기
  3. 멀티 플랫폼 지원
  4. 타도 유니티
```

1. 강력하고 확장성 있는 엔진 (런타임)

   이 목표를 달성하기 위한 기반으로 리플렉션, 가비지컬렉션, 모듈/플러그인등의 개념을 구현한다. 추가적으로 C++상에 리플렉션, 가비지컬렉션을 구현하기(끼워넣기) 위해 매크로 기반의 소스코드 생성기(UHT)의 구현이 필요해 진다.

   > [리플렉션 + 시리얼라이징](UE4-ConceptAndArchitecture.md#%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98--%EC%8B%9C%EB%A6%AC%EC%96%BC%EB%9D%BC%EC%9D%B4%EC%A7%95), [가비지 컬렉션](UE4-ConceptAndArchitecture.md#%EA%B0%80%EB%B9%84%EC%A7%80%EC%BB%AC%EB%A0%89%EC%85%98)

2. 강력하고 확장성 있는 에디터, 코딩 없는 비주얼 스크립팅으로 게임 만들기

   비주얼 스크립팅을 제공하기 위해 런타임 엔진 레벨에 스크립팅 가상머신이 필요해진다. 이것이 BlueprintVM이 되며, 그 기반으로 리플렉션, 시리얼라이징/동적바인딩을 구현해야 한다. 에디터는 그냥 Slate로 만들었다.

   > [블루프린트 VM, 스크립팅 시스템](UE4-ConceptAndArchitecture.md#%EB%B8%94%EB%A3%A8%ED%94%84%EB%A6%B0%ED%8A%B8vm-%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8C%85-%EC%8B%9C%EC%8A%A4%ED%85%9C)

3. 멀티 플랫폼 지원

   멀티플랫폼을 지원하기 위해 각 OS들이 제공하는 기능군 별 API들과 대응되는 추상층을 만들어야 한다. 또한 GC, BlueprintVM과 함께 잘 작동하는 언리얼만의 STL을 구현해야 한다. (TArray 등)

4. 타도 유니티

   유니티는 이미 에디터 커스터마이징, 실행중 소스코드 갱신, 비주얼코딩(PlayMaker), 에셋스토어, Mono를 기반으로 '강력하고 확장성, 생산성 있는 멀티 플랫폼 엔진'을 구현해 놓았다. 이것이 가능한 이유는 C# 이다. 프로그래밍 언어에 리플렉션, GC가 기본으로 있으며 시리얼라이징도 더 견고해 질 수 있다. 추가적으로 컴포넌트 중심의 CBD 프레임워크를 구현해 놓았다.  언리얼은 이것에 대응하기 위해 C++언어를 확장할 필요가 있고, 핫 리로드를 구현해야 하며, 에디터 커스터마이징과 플러그인을 지원할 필요가 있었다. 그러한 이유때문에 UBT, UHT 같은 툴을 만들어야 했다.

   > 언리얼 엔진의 프로그래밍 언어가 C#이었다면 엔진이 복잡한 구조를 갖지 않아도 되었겠지만, C++을 가져간 공식적인 이유까지는 조사하지 않았다. 아마도 성능과 효율의 정확한 제어, 보안, 궁극적인 확장성을 확보하려고 한 것 같다.



## 언리얼 엔진 4의 구조

`언리얼 엔진 4의 구현목표`를 달성하는 언리얼 엔진 4는 크게 3가지 파트로 나눌 수 있다. 툴, 엔진, 에디터이다. 툴은 UBT, UHT, UAT 이다. 엔진은 에디터와 게임이 끌어다 사용하는 런타임 모듈이다. 에디터는 (근본적인 차원에서)데이터와 로직(BP)을 관리/제작하며 엔진의 기능을 FrontEndUI 환경에서 이용할 수 있도록 한다. 엔진 파트의 경우 종속성과 구현의 개념이 낮은순서대로 나열하였다.

1. 툴
   * UBT : uproject지원, 플랫폼별 프로젝트 생성 등
   * UHT : 언어확장, HardCoded TypeInfo generation
   * UAT : 리소스 쿠킹 등

2. 엔진
   * 언어확장 (Unreal C++) : 리플렉션, 가비지컬렉션 - UCLASS(), UObject
   * 언리얼 STL : TArray, Iterators, Delegate, 문자열, 스마트포인터
   * 플랫폼 라이브러리(멀티) : 입력처리, 렌더링, 파일, 네트워크 쓰레드, ... (NDK, ...)
   * 언리얼 Core 라이브러리 : 로그, 시리얼라이저(Struct, Asset, ...), 에셋 레지스트리, Engine/Source/Runtime/Core
   * 월드시스템 : UWorld-ULevel-AActor, ...
   * 스크립팅 엔진 : 블루프린트 VM, VM 디버거
   * 유틸리티 : INI, 크래시핸들러 등
   * 모듈 시스템 : 모듈 관리, 런타임 DLL 교체, 플러그인
   * 언리얼 모듈
   * 서드파티 모듈
   * 커맨드렛
   * Gameplay Framework : GameMode, GameState, Pawn, Controller, ...
     * 네트워크 플레이 : 리플리케이션(동기화), 매칭, 룸, 권한 등

   > 언어확장부터 Gameplay Framework 방향으로 논리적인 레이어가 쌓여간다. 공식적인 구조는 아니지만 엔진을 더 분석하면서 정리해 나갈 예정.

3. 에디터
   * uproject에 대응되는 개념의 편집/관리기
   * Slate로 에디터 윈도우 구현, 엔진 런타임의 기능을 View로 연동
   * 에셋과 에디터 시스템
     * 예: 사운드 에셋과 사운드 에디터, 파티클 에셋과 파티클 에디터 등
       * 이름이 '퍼소나', '케스케이드' 같이 혼동을 줘서 그렇지 결국 '에셋별 에디터'다.
     * 리플렉션, 시리얼라이징을 이용한 사용자 정의 에셋 추가 및 대응 에디터 확장 가능
   * 비주얼 스크립팅 에디터
     * Blueprint VM과의 바인딩
   * 리소스 임포터, 컨텐츠 브라우저
   * 핫 리로드


## 참고사항

### 리플렉션 + 시리얼라이징

리플렉션에 대한 직관적 용어는 RuntimeTypeSystem 정도로 이해하면 된다. C++ 소스코드에서 클래스가 가진 변수/함수의 목록, 타입과 시그니처 및 클래스간의 상속관계같은 정보는 컴파일 된 실행파일에 더이상 존재하지 않는다. 즉, 실행파일은 저수준 장치의 개념에서 데이터와 연산만을 취급한다. 리플렉션은 이미 컴파일된 바이너리의 실행중에 타입 시스템을 제공한다.(이것도 엄밀히는 데이터와 연산일 뿐이지만)

예를들어 `pMyObject`같이 이미 생성된 `Instance`를 이용해서 `ClassTypeID`를 얻을 수 있으며, 원본 클래스 타입의 다양한 정보를 조회할 수 있다. 실행중에 클래스 타입이 가진 변수, 함수의 목록등을 조회하거나 그 '멤버'의 핸들을 얻어내서 `Set`, `Get`, `Call`등을 할 수 있다. `myClassType.Call(pMyObject, functionHandle)` 또는 `myClassType.Call(pMyObject, "TestFunc")` 같은 것을 할 수 있다는 뜻이다.  진보된 리플렉션은 실행시점에 기존에 존재하는 타입에 새로운 멤버 변수 또는 함수를 추가할 수 있다. 또한 새로운 타입도 추가할 수 있다. 더 발전해서 특정 타입과 일치하는 생성되어있는 개체의 목록을 얻는 등의 기능을 가질 수 있을 것 같다.

관계적(계층적) 정보도 제공한다. `myClassType`이 어떤 클래스를 상속받았는지를 실행중에 알아낼 수 있다. 이것은 `dynamic_cast`처럼 어떤 포인터의 다운캐스팅이 가능한지를 실행중에 판단할 수 있다는 뜻이다.  상속도와 관련하여 언리얼의 경우 (UHT를 통해서) C++에는 존재하지 않는 `Super`라는 키워드를 제공한다.

타입정보는 객체의 시리얼라이징에도 도움이 된다. 즉, 파일로 저장되어있는 에셋을 메모리상에 객체로 복원하는 경우(디시리얼라이징) 파일내용이 올바른지를 구조체의 멤버변수 목록등 타입정보와 대조할 수 있다. 이렇게 리플렉션은 파일-메모리간 또는 네트워크-메모리간의 시리얼라이징(객체 저장/복원 및 동기화)에 도움을 준다. RPC(원격함수호출)와 연관되기도 한다. 리플렉션+시리얼라이징 기능은 언리얼 에디터에서 (에셋 브라우저의)템플릿 오브젝트와 맵에 배치된 오브젝트간의 기본값 갱신등을 구현하는데도 기반이 된다.


### 블루프린트VM, 스크립팅 시스템

블루프린트VM은 직관적으로 스크립팅 시스템으로 본다. 간단히 설명하면 컴파일이 완료(타입들이 굳어진 시점)된 후 런타임에 하드디스크에서 로드한 Text파일의 내용으로 새로운 타입을 이용하거나 새로운 로직을 구동하게 해주는 시스템이다. 이것은 리플렉션의 도움으로 가능하다. 언리얼의 경우 이 Text파일 대신 Binary형태의 uasset을 이용하고, 타이핑 방식의 코딩 대신 노드를 끌어다가 연결하는 방식의 비주얼 스크립팅 Editor를 제공하며 이것들을 통틀어 블루프린트 시스템이라고 부른다. 즉, 리플렉션 시스템 바로 위에 블루프린트 VM이 존재하며, VM은 블루프린트 클래스 에셋을 구동한다. 그리고 노드 기반의 FrontEndEditorUI(Slate)가 블루프린트 에디터, 그 에디터에 표시되는 정보를 가져오거나 블루프린트 클래스로 저장하는데 도움을 주는 것이 리플렉션과 시리얼라이저다. 그리고 블루프린트 클래스 에셋은 binary데이터이므로 재 컴파일 없이 로직/데이터의 패치가 가능하다.


## 가비지컬렉션

더이상 사용하지 않는 객체(메모리)를 판단하고 해제해 주는 시스템이 가비지컬렉션 시스템이다. 1959년에 Lisp언어를 위해 존 매카시가 고안한 개념이다. 그는 AI의 선구자이기도 하다.

C언어 계열의 프로그래밍 언어는 '프로그래머가 명시한 작동'이외의 것을 하지 않아야 하는데, C++기반의 언리얼 엔진에 GC가 있기때문에 언리얼 엔진의 이용 초반에 막연한 찝찝함과 단기적인 혼란을 준다.

GC가 왜 사용되었는지 궁금해서 검색해보니 IISWC 2008에서 팀 스위니(언리얼 대빵)가 GC에 대해 "Productivity gain outweighs cost"라고 언급했다. 즉, 언리얼엔진에 GC가 있는 이유는 수동메모리의 관리비용 대신 생산성을 가져가려는 철학의 반영으로 보인다. 하지만 이것은 빠르게 발전하는 PC하드웨어를 염두하고 한 결정이기때문에 현재의 모바일 환경에서는 그의 의도가 유효하지 않다. 따라서 언리얼 GC를 어디까지 활용할지는 프로젝트와 하드웨어에 맞게 조정하면 된다. http://www.iiswc.org/iiswc2008/sildes/keynote_1.pdf

언리얼 엔진은 참조 그래프 방식의 GC구현법을 사용하며 GC는 별도의 쓰레드에서 작동한다. 4.11버전에서 가비지 클러스터링이 추가되었고, 클러스터 병합이라는 기능도 구현되어있다. **가비지 클러스터링은 포함관계**에 있는 객체들이 모두 해제해도 되는 시점까지 기다렸다가 한번에 몰아서 해제하는 것이다. 즉, Actor와 Component들을 모아서 해제하는 방식이다.  **클러스터 병합은 참조관계**에 있는 객체들을 기다렸다가 모아서 해제하는 것이다. 예를들면 파티클 시스템-머터리얼의 참조관계같은 것이며 Room/Level단위 방식의 게임에서 사용하며 스트리밍/오픈월드에서는 적합하지 않다.  언리얼엔진에서 공식문서에서는 TArray만 유일하게 UObject의 참조를 관리해 준다고 적혀있는데, TMap도 참조 관리를 해 준다. (다른 컨테이너는 테스트 해 보지 않았다)

> [언리얼 오브젝트 처리](http://api.unrealengine.com/KOR/Programming/UnrealArchitecture/Objects/Optimizations/index.html)

이후는 자세히 살펴보진 않았지만 MarkAndSweep방식의 GC의 경우 메모리가 하드디스크에 할당(스왑메모리)되면 큰 성능저하를 일으키므로 알아두자.


### TODO: UObject를 생성/파괴하는 함수가 여러 개 이거나 호출스택이 깊은 이유는?


### 액터와 컴포넌트

언리얼 엔진의 월드시스템을 이용할 경우 액터의 기능 확장은 두가지 방법이 있다. 컴포넌트는 has-a 방식의 포함 확장이고, 상속은 is-a 방식의 상속 확장이다. MVC의 측면에서 컴포넌트는 가급적이면 View, Model스러운 것들을 구현하고, 액터에는 Controller스러운 것들(보유한 컴포넌트간 조율, 다른 액터나 월드와의 통신 등)을 구현하면 되지 않을까 싶다. (아직 코딩 제대로 안 해봤음)


### 코드가 실행되는 환경과 시점

C++ 또는 블루프린트로 작성된 코드가 실행되는 환경/시점의 몇 가지 종류가 있다. 게임이 실행될 때의 환경/시점, 에디터 환경에서 에디터를 켤 때 UObject계열의 CDO를 생성하는 시점, 에디터에서 에셋을 관리(레벨에 액터 배치 등)하는 도중에 복사가 되는 시점, PlayInEditor로 게임을 실행하는 환경과 시점, 커맨들렛으로 실행하는 환경으로 구분된다. 각각의 실행시점이나 환경에 따라서 사용 가능여부가 나뉘는 전역 관리자가 있을 수 있으며 해도 되는 코드와 하면 안 되는 코드가 있다.

  **#TODO: 환경과 시점 별 특징 자세히 정리**


### 언리얼 엔진 메인루프

LaunchEngineLoop.cpp

...
