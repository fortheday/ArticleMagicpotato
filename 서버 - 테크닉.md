# 서버 테크닉 정리
* 2003-04-07. magicpotato.
* 2018-01-20 update
* 2000년 초기의 노하우를 다듬은 것이므로, 시대와 안 맞을 수 있다.

## 네트워크 테크닉
1. 사용이 끝난 Session을 즉시 세션풀로 넣지 말고 일정시간 기다렸다가 재사용하게 한다.
2. 간단한 서버를 구현할 때는 세션별로 WSASend/Recv를 위한 각각의 SendBuf, RecvBuf를 둔다. 만약 많은 세션을 처리해야 하는 서버를 구현한다면 버퍼 풀을 만든다음 세션별로 재사용하도록 구조를 잡는다.

## 로직 테크닉
1. 그리드 기반의 서버는 1개 그리드에 2개 이상 객체를 배치할 수 있도록 해야 2차적인 고민거리가 쉽게 해결된다.
2. 세션의 상태별로 컨테이너를 분리하고 Update 빈도를 제어하자.
   1. 서버가 바쁘면 비인증 세션은 상대적으로 늦게 처리해줘도 된다.
3. 컨테이너의 순회는 Add, Update, Remove 용도별로 각각 분리한다. (멀티쓰레드/안정성)
   1. 특히 삭제는 Session.RemoveReserved 같은 플래그를 넣고 처리한다.
4. 플레이어의 일부 데이터가 다른 쓰레드에서 처리되어야 할 경우 처리단위별 구조체로 분리하는게 유리하며, 처리단위별 구조체에 따로 메모리풀을 적용할 수 있다.
5. 클라이언트와 서버간의 게임시간을 동기화 해야 한다.
   1. 동기화에 쓰이는 시간 데이터는 게임 절대시간으로 전송한다.
   2. 최적화를 하고싶다면 이후로는 분/초 단위의 시간값을 주고받는다.(요즘시대에 그다지..)
6. 로직 프로토콜중 액터의 시야, 플레이어간 동기화 처리가 근본 핵심이다.
   1. 액터간 거리에 따른 단계별 동기화 수준 제어 (패킷 전송량 문제)
   2. 액터간 동기화 단계에 따른 상호작용 단계 제어
      1. 적대적 행위의 대상자가 납득하려면 최고수준의 동기화가 된 이후에 가능하므로 '순간이동'같은 스킬은 강제로 최고동기화를 해 준 다음 스킬을 사용하도록 할 수 있다.
      2. 또는 상호작용과 시야처리의 종속관계를 느슨하게 가져갈 수 있다. (고민안해봄)
   3. 시야 범위 진입/이탈에 의한 액터 추가/삭제는 느슨하게 처리해야 한다.
      1. 시야범위에서 진입/이탈을 반복할 때 패킷낭비와 클라이언트의 액터 생성/삭제 반복을 하지 않아야 한다.
      2. 퍼지이론스럽게 해야 한다고 표현해야 하나. 어떻게 간결하게 표현해야할지 모르겠다.

## 구시대유산 - 그리드 자료구조의 객체 플래그팩 기법
그리드별 객체 존재여부를 8개씩 묶어 bool bit packing처럼 사용하면 큰 맵의 루프 수를 줄일 수 있다.

## 한줄 메모들

- 메인루프 : 서로다른 시간 간격별로 각각의 함수를 호출 (주로 void)
- 메인루프 : 키보드 입력에 의해 어떤 기능을 수행하는 부분
- 모니터링 : 게임의 대부분의 정보를 실시간 확인 가능해야 한다.
- 로그처리 : 게임에 사용되는 구조체들의 상태를 text화 하는 루틴
- 로그처리 : 사용자별로 로그를 따로 저장하는 루틴
- 오류검증 : 게임에 종속된 '자료형'에 대한 범위 및 값 검사 루틴
- 오류검증 : 주어진 구조체에 대한 '통합검증' 루틴
- 운영권한 : 로컬/리모트에 의해 게임데이터를 변조할수 있다.
- 처리결과 : 어떤 처리에 대한 결과를 일규격화 시킨다.
- 루프처리 : 어느곳에서든 '루프(i,j-for)'에 영향받지 않고 처리해야 한다.
- 객체처리 : 게임의 객체는 공통적인 처리가 되어야 한다.
- 패킷처리 : 패킷을 만들어 보내는 루틴이 정규화, 그룹화 되어야 한다.
- 변수처리 : 주요 변수의 최소/최대값 정보를 보유, 대입시 함수로 대입한다
(범위값 검사 루틴에, 자동 값 조절등의 기능을 제공)
(2타입으로 리턴값에 적용된값, 리턴없는 함수등을 제공)
- 패킷처리 : 어느 패킷에나 거의 들어가는 '시간'값 같은것 대입하는 루틴필요
- 패킷변환 : 특정 패킷구조체 <-> 런타임구조체 <-> 저장구조체 변환기 묶음
- 랜덤처리 : 어떤곳에서든 랜덤으로 처리될수 있도록 최소100확률의 루틴 필요
- 객체관리 : 한 그리드에 2객체 이상이 들어갈수 있게 설계되어야 한다.
- 전송분리 : 어떤 작업이든 '패킷을 안보낼 수'있게 제작해야 한다.
- 루프관리 : 비로긴자, 비게임자, 맵 대기자/입장자의 효율적인 전환 관리
- 패킷처리 : 프로토콜 커맨드별 처리 루틴 연결부
- 패킷처리 : 효율적인 버퍼 관리(달팽이식)
- 보조루틴 : 실패해도 전체 루틴에 큰 영향을 미치지 않는 쓰레드 작성
- 오류검증 : 개선된 루틴의 수치범위를 벗어나는 데이터 파일을 보정
- 시야처리 : 처음 시야구축 루틴에 '부분구축'루틴이 쓰이면 좋다.
- 보안관련 : SQL루틴에 id/pass를 넣지 말고, config로 처리한다.

- 플레이어에 값을 적용했다가, 해제 되는 루틴 (부가상태)
- 실패하면 안되는 저장(캐릭터 정보 등)에 대한 솔루션
- 어떤 데이터 파일이든 같은 루틴(XML같은 정규화로)으로 읽을수 있는 솔루션
- 에너미 등급별로 어떤 수치든 다르게 처리하기 위한 자료구조(hp/다운프레임)
- 한 변수의 옵셋(예:아이템 인벤토리15개, 퀵아이템5개 합해서 20까지)값을
분리해 주는 함수 필요

## 서버 런칭후 최근 두드러 지는 문제점들
```
제대로된 서버를 짜본것이 이번이 처음이기 때문에
두려운 점도 많았고 미숙한점도 많았는데..
그중 문제 되는 점을 정리해 놓을까 합니다.

1) SQL
일단.. 가장 큰 문제가 '모르는 기술'을 대충 짜놓으면 안된다는것..
SQL 같은 경우 OLEDB를 사용했기 때문에..(국내 서적이 개판임)
'구현'에 중점을 두고.. 에러처리에 대한 확실한 검증이 없었죠..
요즘 이 부분때문에 서버가 가장 많이 다운됩니다. (거의 이것때문에만-_-)
주요 원인과 아쉬운점..
- 연속으로 뭔가 요청할 경우 쓰레드가 블럭되는데.. 그 중간의 큐 처리가 까다로움
- SQL금지문자가 있는데 이것을 사용할 경우 에러처리를 제대로 해 주어야 함
- SQL서버가 꺼져도 게임서버가 돌아가게 되어야 함


2) 데이터 조작 & 관리
기획이 변경되면 코드만 바뀌는것이 아니라 데이터가 변경되어야 하는데..
런타임 상 또는 서버가 안돌아 가는 상황에서 데이터를 초기화 시켜줘야 할때가 있습니다
(데이터는 그대로 두고 스탯포인트를 재 환산 해준다든지.. LV를 일괄적으로 낮춘다든지)
이런 경우에 일단 임시 방편으로.. 일괄 처리 유틸리티를 작성하게 되는데..
원격으로 서버 업데이트시에 상당히 불편합니다.
캐릭터 복구하기도 힘들고..
'런타임'상에서 데이터를 바로바로 수정할수 있는 툴이 필요하죠..

또 사용자 캐릭터 정보같은건 게임서버가 함께 갖는 경우가 있는데..
파일이 깨져도 로딩되게 작성하거나, 자동으로 온전한 최근의 데이터를
불러올수 있도록 백업 처리를 확실히 해줘야 합니다.

그래야 '프로그래머 외이 다른사람'이 서버를 조작할수 있으니까요.
(이거 상당히 중요 -_ㅜ)


3) 로그
로그.....상당히 중요합니다.
최근 겪은일인데.
프로그램 구조상으로 절대로 불가능한 일인데..
버그라면서 전화를 해서는 캐릭터 스탯을 재분해 해줄수 있게 해달라고 떼쓴다는;;;;;
사용자의 주요 행동 하나하나를 꼭 기록해 두어야 합니다.
뻥쳐도 할말 없더군요 -_-;
뭐 신고시에는 사기나 버그플레이도 잡아낼수 있으니 꼭 해두어야 합니다.

다만 파일 기록을 하면 느려지니 반드시 로그서버는 C/S 구조로...
```

EOF
