# 서버 테크닉 정리
* 2003-04-07. magicpotato.
* 2018-01-20 update
* 2000년 초기의 노하우를 다듬은 것이므로, 시대와 안 맞을 수 있다.

## 네트워크 테크닉
1. 사용이 끝난 Session을 즉시 세션풀로 넣지 말고 일정시간 기다렸다가 재사용하게 한다.
2. 간단한 서버를 구현할 때는 세션별로 WSASend/Recv를 위한 각각의 SendBuf, RecvBuf를 둔다. 만약 많은 세션을 처리해야 하는 서버를 구현한다면 버퍼 풀을 만든다음 세션별로 재사용하도록 구조를 잡는다.

## 로직 테크닉
1. 그리드 기반의 서버는 1개 그리드에 2개 이상 객체를 배치할 수 있도록 해야 2차적인 고민거리가 쉽게 해결된다.
2. 세션의 상태별로 컨테이너를 분리하고 Update 빈도를 제어하자.
   1. 서버가 바쁘면 비인증 세션은 상대적으로 늦게 처리해줘도 된다.
3. 컨테이너의 순회는 Add, Update, Remove 용도별로 각각 분리한다. (멀티쓰레드/안정성)
   1. 특히 삭제는 Session.RemoveReserved 같은 플래그를 넣고 처리한다.
4. 플레이어의 일부 데이터가 다른 쓰레드에서 처리되어야 할 경우 처리단위별 구조체로 분리하는게 유리하며, 처리단위별 구조체에 따로 메모리풀을 적용할 수 있다.
5. 클라이언트와 서버간의 게임시간을 동기화 해야 한다.
   1. 동기화에 쓰이는 시간 데이터는 게임 절대시간으로 전송한다.
   2. 최적화를 하고싶다면 이후로는 분/초 단위의 시간값을 주고받는다.(요즘시대에 그다지..)
6. 로직 프로토콜중 액터의 시야, 플레이어간 동기화 처리가 근본 핵심이다.
   1. 액터간 거리에 따른 단계별 동기화 수준 제어 (패킷 전송량 문제)
   2. 액터간 동기화 단계에 따른 상호작용 단계 제어
      1. 적대적 행위의 대상자가 납득하려면 최고수준의 동기화가 된 이후에 가능하므로 '순간이동'같은 스킬은 강제로 최고동기화를 해 준 다음 스킬을 사용하도록 할 수 있다.
      2. 또는 상호작용과 시야처리의 종속관계를 느슨하게 가져갈 수 있다. (고민안해봄)
   3. 시야 범위 진입/이탈에 의한 액터 추가/삭제는 느슨하게 처리해야 한다.
      1. 시야범위에서 진입/이탈을 반복할 때 패킷낭비와 클라이언트의 액터 생성/삭제 반복을 하지 않아야 한다.
      2. 퍼지이론스럽게 해야 한다고 표현해야 하나. 어떻게 간결하게 표현해야할지 모르겠다.

## 구시대유산 - 그리드 자료구조의 객체 플래그팩 기법
그리드별 객체 존재여부를 8개씩 묶어 bool bit packing처럼 사용하면 큰 맵의 루프 수를 줄일 수 있다.

## 한줄 메모들

- 메인루프 : 서로다른 시간 간격별로 각각의 함수를 호출 (주로 void)
- 메인루프 : 키보드 입력에 의해 어떤 기능을 수행하는 부분
- 모니터링 : 게임의 대부분의 정보를 실시간 확인 가능해야 한다.
- 로그처리 : 게임에 사용되는 구조체들의 상태를 text화 하는 루틴
- 로그처리 : 사용자별로 로그를 따로 저장하는 루틴
- 오류검증 : 게임에 종속된 '자료형'에 대한 범위 및 값 검사 루틴
- 오류검증 : 주어진 구조체에 대한 '통합검증' 루틴
- 운영권한 : 로컬/리모트에 의해 게임데이터를 변조할수 있다.
- 처리결과 : 어떤 처리에 대한 결과를 일규격화 시킨다.
- 루프처리 : 어느곳에서든 '루프(i,j-for)'에 영향받지 않고 처리해야 한다.
- 객체처리 : 게임의 객체는 공통적인 처리가 되어야 한다.
- 패킷처리 : 패킷을 만들어 보내는 루틴이 정규화, 그룹화 되어야 한다.
- 변수처리 : 주요 변수의 최소/최대값 정보를 보유, 대입시 함수로 대입한다
(범위값 검사 루틴에, 자동 값 조절등의 기능을 제공)
(2타입으로 리턴값에 적용된값, 리턴없는 함수등을 제공)
- 패킷처리 : 어느 패킷에나 거의 들어가는 '시간'값 같은것 대입하는 루틴필요
- 패킷변환 : 특정 패킷구조체 <-> 런타임구조체 <-> 저장구조체 변환기 묶음
- 랜덤처리 : 어떤곳에서든 랜덤으로 처리될수 있도록 최소100확률의 루틴 필요
- 객체관리 : 한 그리드에 2객체 이상이 들어갈수 있게 설계되어야 한다.
- 전송분리 : 어떤 작업이든 '패킷을 안보낼 수'있게 제작해야 한다.
- 루프관리 : 비로긴자, 비게임자, 맵 대기자/입장자의 효율적인 전환 관리
- 패킷처리 : 프로토콜 커맨드별 처리 루틴 연결부
- 패킷처리 : 효율적인 버퍼 관리(달팽이식)
- 보조루틴 : 실패해도 전체 루틴에 큰 영향을 미치지 않는 쓰레드 작성
- 오류검증 : 개선된 루틴의 수치범위를 벗어나는 데이터 파일을 보정
- 시야처리 : 처음 시야구축 루틴에 '부분구축'루틴이 쓰이면 좋다.
- 보안관련 : SQL루틴에 id/pass를 넣지 말고, config로 처리한다.

- 플레이어에 값을 적용했다가, 해제 되는 루틴 (부가상태)
- 실패하면 안되는 저장(캐릭터 정보 등)에 대한 솔루션
- 어떤 데이터 파일이든 같은 루틴(XML같은 정규화로)으로 읽을수 있는 솔루션
- 에너미 등급별로 어떤 수치든 다르게 처리하기 위한 자료구조(hp/다운프레임)
- 한 변수의 옵셋(예:아이템 인벤토리15개, 퀵아이템5개 합해서 20까지)값을
분리해 주는 함수 필요

EOF
