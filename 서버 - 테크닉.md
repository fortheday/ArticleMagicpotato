# 서버 테크닉 정리
* 2018-01-20. magicpotato.
* 2000년 초기의 노하우를 다듬은 것이므로, 시대와 안 맞을 수 있다.

## 네트워크 테크닉
1. 사용이 끝난 Session을 즉시 세션풀로 넣지 말고 일정시간 기다렸다가 재사용하게 한다.
2. 간단한 서버를 구현할 때는 세션별로 WSASend/Recv를 위한 각각의 SendBuf, RecvBuf를 둔다. 만약 많은 세션을 처리해야 하는 서버를 구현한다면 버퍼 풀을 만든다음 세션별로 재사용하도록 구조를 잡는다.

## 로직 테크닉
1. 그리드 기반의 서버는 1개 그리드에 2개 이상 객체를 배치할 수 있도록 해야 2차적인 고민거리가 쉽게 해결된다.
2. 세션의 상태별로 컨테이너를 분리하고 Update 빈도를 제어하자.
   1. 서버가 바쁘면 비인증 세션은 상대적으로 늦게 처리해줘도 된다.
3. 컨테이너의 순회는 Add, Update, Remove 용도별로 각각 분리한다. (멀티쓰레드/안정성)
   1. 특히 삭제는 Session.RemoveReserved 같은 플래그를 넣고 처리한다.
4. 플레이어의 일부 데이터가 다른 쓰레드에서 처리되어야 할 경우 처리단위별 구조체로 분리하는게 유리하며, 처리단위별 구조체에 따로 메모리풀을 적용할 수 있다.
5. 클라이언트와 서버간의 게임시간을 동기화 해야 한다.
   1. 동기화에 쓰이는 시간 데이터는 게임 절대시간으로 전송한다.
   2. 최적화를 하고싶다면 이후로는 분/초 단위의 시간값을 주고받는다.(요즘시대에 그다지..)
6. 로직 프로토콜중 액터의 시야, 플레이어간 동기화 처리가 근본 핵심이다.
   1. 액터간 거리에 따른 단계별 동기화 수준 제어 (패킷 전송량 문제)
   2. 액터간 동기화 단계에 따른 상호작용 단계 제어
      1. 적대적 행위의 대상자가 납득하려면 최고수준의 동기화가 된 이후에 가능하므로 '순간이동'같은 스킬은 강제로 최고동기화를 해 준 다음 스킬을 사용하도록 할 수 있다.
      2. 또는 상호작용과 시야처리의 종속관계를 느슨하게 가져갈 수 있다. (고민안해봄)
   3. 시야 범위 진입/이탈에 의한 액터 추가/삭제는 느슨하게 처리해야 한다.
      1. 시야범위에서 진입/이탈을 반복할 때 패킷낭비와 클라이언트의 액터 생성/삭제 반복을 하지 않아야 한다.
      2. 퍼지이론스럽게 해야 한다고 표현해야 하나. 어떻게 간결하게 표현해야할지 모르겠다.

## 구시대유산 - 그리드 자료구조의 객체 플래그팩 기법
그리드별 객체 존재여부를 8개씩 묶어 bool bit packing처럼 사용하면 큰 맵의 루프 수를 줄일 수 있다.

EOF